package main

import "fmt"

type Matrix [][]int

func (m Matrix) Mul(n Matrix, mod int) Matrix {
	o := make(Matrix, len(m))
	for i := range o {
		o[i] = make([]int, len(m[0]))
	}
	for i := 0; i < len(m); i++ {
		for j := 0; j < len(n[0]); j++ {
			for k := 0; k < len(m[0]); k++ {
				o[i][j] += m[i][k] * n[k][j]
			}
			o[i][j] %= mod
		}
	}
	return o
}

func (m Matrix) Pow(n int, mod int) Matrix {
	p := m
	q := make(Matrix, len(m))
	for i := range q {
		q[i] = make([]int, len(m[0]))
		q[i][i] = 1
	}
	for i := 0; i < 60; i++ {
		if n&(1<<i) != 0 {
			q = q.Mul(p, mod)
		}
		p = p.Mul(p, mod)
	}
	return q
}

var m2 = Matrix{
	{0, 0, 0, 1},
	{0, 0, 1, 0},
	{0, 1, 0, 0},
	{1, 0, 0, 1},
}

var m3 = Matrix{
	{0, 0, 0, 0, 0, 0, 0, 1},
	{0, 0, 0, 0, 0, 0, 1, 0},
	{0, 0, 0, 0, 0, 1, 0, 0},
	{0, 0, 0, 0, 1, 0, 0, 1},
	{0, 0, 0, 1, 0, 0, 0, 0},
	{0, 0, 1, 0, 0, 0, 0, 0},
	{0, 1, 0, 0, 0, 0, 0, 1},
	{1, 0, 0, 1, 0, 0, 1, 0},
}

var m4 = Matrix{
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1},
	{0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0},
	{0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
	{0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1},
	{0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
	{0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0},
	{1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1},
}

func main() {
	var k, n int
	fmt.Scan(&k, &n)

	var a Matrix
	switch k {
	case 2:
		a = m2
	case 3:
		a = m3
	case 4:
		a = m4
	}

	b := a.Pow(n, 1000000007)

	fmt.Println(b[(1<<k)-1][(1<<k)-1])
}
